<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogWidth" value="542" />
    <option name="newTranslationDialogX" value="623" />
    <option name="newTranslationDialogY" value="348" />
    <histories>
      <item value="테두리" />
      <item value="구분선" />
      <item value="줄 바꿈" />
      <item value="줄바꿈" />
      <item value="줄바꾼" />
      <item value="회색" />
      <item value="api 무작위 호출" />
      <item value="api " />
      <item value="비즈니스" />
      <item value="검색가능한" />
      <item value="s" />
      <item value="폰트" />
      <item value="When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding." />
      <item value="고장난 구독" />
      <item value="고장난" />
      <item value="보장되는 실행" />
      <item value="실행" />
      <item value="Comparisons of dissimilar types will always return false. The comparison and all its dependent code can simply be removed. This includes:&#10;comparing an object with null&#10;comparing an object with an unrelated primitive (E.G. a string with an int)&#10;comparing unrelated classes&#10;comparing an unrelated class and interface&#10;comparing unrelated interface types&#10;comparing an array to a non-array&#10;comparing two arrays" />
      <item value="Silly equality checks should not be made" />
      <item value="Specifically in the case of arrays, since arrays don’t override Object.equals(), calling equals on two arrays is the same as comparing their addresses. This means that array1.equals(array2) is equivalent to array1==array2.&#10;However, some developers might expect Array.equals(Object obj) to do more than a simple memory address comparison, comparing for instance the size and content of the two arrays. Instead, the == operator or Arrays.equals(array1, array2) should always be used with arrays." />
      <item value="구독 해지" />
      <item value="구독 취소" />
      <item value="실행되지 않는 구독" />
      <item value="실행하지 않는 구독" />
      <item value="작동하지 않는 구독" />
      <item value="동작하지 않는 구독" />
      <item value="진행되지 않는 구독" />
      <item value="ㅓ" />
      <item value="아무것도하지않는 구독" />
      <item value="싱글 구독" />
      <item value="싱글 " />
      <item value="구독 함수" />
      <item value="상단바 높이" />
      <item value="상단바 세로" />
      <item value="상단바 " />
      <item value="수수료" />
      <item value="tntn" />
      <item value="사각형" />
      <item value="facets" />
      <item value="An async function always wraps the return value in a Promise. Using return await is therefore redundant." />
      <item value="It is possible to use await on values which are not Promises, but it’s useless and misleading. The point of await is to pause execution until the Promise's asynchronous code has run to completion. With anything other than a Promise, there’s nothing to wait for.&#10;This rule raises an issue when an awaited value is guaranteed not to be a Promise." />
      <item value="redundant" />
      <item value="re" />
      <item value="punctuation" />
      <item value="punctuat" />
      <item value="deny" />
      <item value="diny" />
      <item value="dena" />
      <item value="denai" />
      <item value="디나이" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="55" />
        <entry key="KOREAN" value="98" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1637583492700" />
  </component>
  <component name="Settings">
    <option name="phoneticFontFamily" value="AppleSDGothicNeoL00" />
    <option name="primaryFontFamily" value="AppleSDGothicNeoM00" />
  </component>
</application>